<!DOCTYPE html>
<html>
<head></head>
<body>    

<button id="run_backend_process" onclick="run_backend_process()" style="display:block">run_backend_process</button>

<div id="notification" style="display:block"></div>
<div id="error" style="display:block"></div>


<script>

// ----------------------------------------------------

const repoOwner = 'CodeSolutions2';
const repoName = 'run_GitHub_Actions';

var n = 2; // maximum salt length used
var input_text = 'input text from frontend to backend';


// ----------------------------------------------------

	
async function run_backend_process() {

  await GET_text_from_file_wo_auth_GitHub_RESTAPI(".env")
    .then(async function(obj_env) {  return await decode_desalt(obj_env); })
    .then(async function(obj_env) { await run_backend(obj_env); })
    .catch(error => { document.getElementById("error").innerHTML = error; });

}

	

// ----------------------------------------------------


async function decode_desalt(obj_env) {
	
	// 0. Decode the Base64-encoded string --> obtain the salted data in binary string format
	const text = atob(obj_env.text);
	
	// 1. 'de-salt' the authorization key read from the file
	let arr_auth = [];

	for (let i=1; i<n+1; i++) {
		// remove end
		arr_auth.push(text.slice(0, text.length-i));

		// remove beginning
		arr_auth.push(text.slice(i, text.length));
	}

	// Add arr_auth to obj_env
	obj_env.arr_auth = arr_auth;

	console.log("obj_env: ", obj_env);
	
	return obj_env;
}

	
// ----------------------------------------------------

	
async function run_backend(obj_env) {
	
	// Try each of the 'de-salted' authorization keys to identify the correct key: loop over a REST API request and identify which key succeeds
	
	// [0] Determine if temp exists
	await GET_fileDownloadUrl_and_sha("temp")
		// [1] Test for the correct key, save input_text to temp
		.then(async function(obj_temp) { 
			let desired_path = obj_temp.file_download_url[0].split('main/').pop();
			console.log('desired_path: ', desired_path);
			
			if (obj_temp.file_download_url == "No file found") {
				// Option 0: create a new file
				return await PUT_create_a_file_RESTAPI(obj_env.arr_auth[0], 'run GitHub Action', input_text, desired_path)
					.then(async function(out) { obj_temp.status = out.status; return obj_temp; });
			} else {
				// Option 1: modify an existing file
				return await PUT_add_to_a_file_RESTAPI(obj_env.arr_auth[0], 'run GitHub Action', input_text, desired_path, obj_temp.sha_arr[0])
					.then(async function(out) { obj_temp.status = out.status; return obj_temp; });
			}
		})
		.then(async function(obj_temp) { 
			await new Promise(r => setTimeout(r, 2000)); 
			console.log('obj_temp.status: ', obj_temp.status);
			return obj_temp; 
		})
		.then(async function(obj_temp) {
			let i = 1;
			let desired_path = obj_temp.file_download_url[0].split('main/').pop();
			console.log('desired_path: ', desired_path);

			var regexp = /^20/g;
 
			while (regexp.test(obj_temp.status) == false && i < obj_env.arr_auth.length) {
		 		if (obj_temp.file_download_url == "No file found") {
					// Option 0: create a new file
		 			obj_temp = await PUT_create_a_file_RESTAPI(obj_env.arr_auth[i], 'run GitHub Action', input_text, desired_path)
		 				.then(async function(out) { obj_temp.status = out.status; await new Promise(r => setTimeout(r, 2000)); return obj_temp; })
		 		} else {
		 			// Option 1: modify an existing file
		 			obj_temp = await PUT_add_to_a_file_RESTAPI(obj_env.arr_auth[i], 'run GitHub Action', input_text, desired_path, obj_temp.sha_arr[0])
		 				.then(async function(out) { obj_temp.status = out.status; await new Promise(r => setTimeout(r, 2000)); return obj_temp; })
		 		}
				
				if (regexp.test(obj_temp.status) == true) {
					obj_env.auth = obj_env.arr_auth[i];
				}
				console.log('obj_temp.status: ', obj_temp.status);
		 		i += 1;
		 	}
			delete obj_env.arr_auth;
			console.log("obj_env: ", obj_env);
		 	return obj_env;
		})
		.then(async function(obj_env) { 
		 	document.getElementById("notification").innerHTML = "Backend process launching...";
		 	console.log("Backend process launching...");
		})
		.catch(error => { document.getElementById("error").innerHTML = error; });
	
}

	


// ----------------------------------------------------
// SUBFUNCTIONS
// ----------------------------------------------------

async function DELETE_a_file_RESTAPI(auth, message, desired_filename, sha) {

	var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${desired_filename}`;
	var data = {"message": message, "committer":{"name":"App name","email":"App email"}, "sha": sha};
	var headers = {"Accept": "application/vnd.github+json", "Authorization": `Bearer ${auth}`, "X-GitHub-Api-Version": "2022-11-28"};
	var options = {method : 'DELETE', headers: headers, body : JSON.stringify(data)};
	
	return await fetch(url, options)
		.catch(error => { document.getElementById("error").innerHTML = error; });
}
	

// ----------------------------------------------------
// PUT create a file - Way 0: REST API (WORKS!)
// Can only write to a public repository, can not write to a private repository even if the key grants access
// https://docs.github.com/en/rest/repos/contents?apiVersion=2022-11-28#create-or-update-file-contents
// 
// Before, GitHub copied over the temp file with a new temp.
//
// Now, if the file temp exists it does not copy over the file; it gives a 422 error. One needs to delete the file temp and then use this function to create the file temp. 
// ----------------------------------------------------
async function PUT_create_a_file_RESTAPI(auth, message, content, desired_path) {
	
	// PUT content into a new file
	var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${desired_path}`;
	var data = {"message": message, "committer":{"name":"App name","email":"App email"}, "content": btoa(content)};
	var headers = {"Accept": "application/vnd.github+json", "Authorization": `Bearer ${auth}`, "X-GitHub-Api-Version": "2022-11-28"};
	var options = {method : 'PUT', headers: headers, body : JSON.stringify(data)};
	
	return await fetch(url, options)
		.catch(error => { document.getElementById("error").innerHTML = error; });
}


// ----------------------------------------------------


async function PUT_add_to_a_file_RESTAPI(auth, message, content, desired_path, sha) {
	
	// PUT content into an existing file
	let url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${desired_path}`;
	var data = {"message": message, "committer":{"name":"App name","email":"App email"}, "content": btoa(content), "sha": sha};
	var headers = {"Accept": "application/vnd.github+json", "Authorization": `Bearer ${auth}`, "X-GitHub-Api-Version": "2022-11-28"};
	var options = {method : 'PUT', headers: headers, body : JSON.stringify(data)};
	
	return await fetch(url, options)
		.catch(error => { document.getElementById("error").innerHTML = error; });
}
	
// ----------------------------------------------------

async function GET_text_from_file_wo_auth_GitHub_RESTAPI(desired_filename) {
	
	return await GET_fileDownloadUrl_and_sha(desired_filename)
		.then(async function (obj) { 
			var text = "";
			if (obj.file_download_url != "No file found") {
				// fetch on first file
				text = await fetch(obj.file_download_url[0])
					.then(response => response.text())
					.then(async function(text) { return text; });
			}
			// console.log("text: ", text);
			return {text: text, file_download_url: obj.file_download_url[0], sha_arr: obj.sha_arr[0]};
		})
		.catch(error => { document.getElementById("error").innerHTML = error; });
}

// ----------------------------------------------------

async function GET_fileDownloadUrl_and_sha(desired_filename) {
	
	var url = `https://api.github.com/repos/${repoOwner}/${repoName}/contents`;
	
	var file_download_url = [];
	var folders = [];
	var sha_arr = [];
	var flag = "run";
	var max_loop_limit = 0;
	
	return await fetch(url)
		.then(res => res.json())
		.then(async function(data) {
			
			while (flag == "run" && max_loop_limit < 5) {
				// search over data for the desired_filename
				var obj = await loop_over_files_and_folders(data, desired_filename, file_download_url, folders, sha_arr);

				folders = folders.concat(obj.folders);
				folders = [... new Set(folders)];
				// console.log("folders: ", folders);
				
				file_download_url = file_download_url.concat(obj.file_download_url);
				file_download_url = [... new Set(file_download_url)];
				sha_arr = sha_arr.concat(obj.sha_arr);
				sha_arr = [... new Set(sha_arr)];
				
				// console.log("file_download_url: ", file_download_url);
				// console.log("folders.length: ", folders.length);
				
				// get list of folders from the main directory
				if (folders.length == 0) {
					flag = "stop";
					if (file_download_url.length == 0) { file_download_url = "No file found"; }
					if (sha_arr.length == 0) { sha_arr = "No file found"; }
				} else {
					// There are directories in the main file
					data = await fetch(folders.shift())
						.then(res => res.json())
						.then(async function(data) { return data; });
				}
				max_loop_limit += 1;
				// console.log("max_loop_limit: ", max_loop_limit);
			}
			return {file_download_url: file_download_url, sha_arr: sha_arr};
		})
		.catch(error => { document.getElementById("error").innerHTML = error; });
	
}

	
async function loop_over_files_and_folders(data, desired_filename, file_download_url, folders, sha_arr) {

	var regexp = new RegExp(`${desired_filename}`, 'g');
	
	// run through files per url directory
	data.forEach(async function(file) {
		if (file.type === 'file' && file.name.match(regexp)) { 
			file_download_url = file.download_url;
			sha_arr = file.sha;
			console.log('Desired file found: ', file.url);
		} else if (file.type === 'dir') {
			// Store url of directories found
			folders.push(file.url);
			console.log('A directory was found: ', file.url);
		} else {
			console.log('Desired file not found: ', file.url);
		}
	});
	return {file_download_url: file_download_url, folders: folders, sha_arr: sha_arr}; 
}

// ----------------------------------------------------


</script>

  </body>
</html>
