<!DOCTYPE html>
<html>
<head></head>
<body>

<!-- ---------------------------------------- -->
<!-- View two split window -->
<div align="left">
<table style='text-align: left; width: 500px; display:block'>
<tr>

<th id="inputs">

<h1></h1>

<h3>[Step 0] Select a chatbot model</h3>
<fieldset>
<input type="radio" id="openAI3_5" name="radio_name" value="openAI3_5" />
<label openAI3_5="openai">OpenAI 3.5</label>
<br>
<input type="radio" id="openAIassistant" name="radio_name" value="openAIassistant" />
<label for="openAIassistant">OpenAI Assistant</label>
<br>
<input type="radio" id="custom_model" name="radio_name" value="custom_model" />
<label for="custom_model">Custom Model</label>
</fieldset>
<br>
<div id="notification"></div>
<div id="error"></div>
<div id="response"></div>
<div id="output_file_path" style="display:none;"></div>
<div id="var0" style="display:none;"></div>
<div id="var1" style="display:none;"></div>
<div id="var2" style="display:none;"></div>
<div id="var3" style="display:none;"></div>
<br>

</th>

<!-- ---------------------------------------- -->
<th id="outputs">
<h3 id="table_h3" style="display:block">[Step 1]</h3>
<!-- ---------------------------------------- -->
<!-- View output in table -->
<input id="input_text" type="text" value="" placeholder="" rows="10" cols="100" style="display:block; text-align: left; height: 50px; width:600px;"><button id="run_selection" onclick="run_selection()">Run Selection</button><button id="run_selection" onclick="print_result()">Print result</button>
<table id="chatbot_output" style='text-align: left; width: 300px; display:none'>
<!-- dynamically add rows here -->
</table>
<!-- ---------------------------------------- -->
</th>

</tr>
</table>
</div>  
<!-- ---------------------------------------- -->

<!-- ---------------------------------------- -->
<!-- CSS -->
<style>
div { padding: 10px; display:block; font-family:courier; font-size:15px; height:10px; }
	
div#notification { position: relative; color: #3236a8; }
div#error { position: relative; color: #bd1f17; }
div#response { display:none; color: #3236a8; }

table {vertical-align: top; border-collapse: collapse; position: relative; z-index: 0; border: 0px solid black;}

tr {vertical-align: top; border: 0px solid black; padding: 20px 10px; }

th, td {vertical-align: top; border: 0px solid black; padding: 20px 10px; }

input#input_text {background-color: #acbdac; border: 0.5px grey; -webkit-border-radius: 5px;-moz-border-radius: 5px;border-radius: 5px;}
</style>


<!-- --------------------------------------------------- -->	  

	
<script>

// -----------------------------------------------
	
async function run_selection() {

	var RepoAobj = {};
	
	const openAI3_5 = document.getElementById("openAI3_5").checked;
	const openAIassistant = document.getElementById("openAIassistant").checked;
	const custom_model = document.getElementById("custom_model").checked;
	
	RepoAobj.repoOwner = 'CodeSolutions2';
	RepoAobj.repoA_name = 'my_chatbot';
	
	if (openAI3_5 == true && openAIassistant == false && custom_model == false) {
		RepoAobj.foldername = 'openAI3_5';
		await selection_steps(RepoAobj);
	}
	if (openAI3_5 == false && openAIassistant == true && custom_model == false) {
		RepoAobj.foldername = 'openAIassistant';
		await selection_steps(RepoAobj);
	}
	if (openAI3_5 == false && openAIassistant == false && custom_model == true) {
		RepoAobj.foldername = 'custom_model';
		await selection_steps(RepoAobj);
	}
	if (openAI3_5 == false && openAIassistant == false && custom_model == false) {
		document.getElementById('error').innerHTML = "Please select a chatbot model.";
	}
}

async function selection_steps(RepoAobj) {

	// RepoAobj.repoOwner, RepoAobj.repoA_name, RepoAobj.foldername
	
	RepoAobj.filename = 'cb.txt';
	RepoAobj.input = document.getElementById("input_text").value+"|"+RepoAobj.repoA_name;
	RepoAobj.repoB_name = 'frontend_backend_message_passing_central_repository_v0';

	// Save file name to DOM
	document.getElementById('output_file_path').innerHTML = RepoAobj.foldername+'_response';
	
	await run_backend_process(RepoAobj);

	// RepoAobj.repoOwner, RepoAobj.repoA_name, RepoAobj.foldername, RepoAobj.filename, RepoAobj.input, RepoAobj.repoB_name

	// Last step: how does one know when to perform a GET request on the file to present it on the browser?
	// document.getElementById('response').innerHTML = 'in progress';
	// await print_response_to_frontend();
	// OR
	// await automatic_print_result()
}

// -----------------------------------------------

async function automatic_print_result() {

	// Wait for file creation
	var flag = "run";
	var i = 0;
	while (flag == "run" && i < 15) {
		// keep doing GET on the repo files for 'response' until it appears
		flag = await GET_repo_file_info_RESTAPI_fast()
			.then(async function (text_out) {
				console.log('text_out: ', text_out);
				
				if (text_out != '404: Not Found') {
					document.getElementById('response').innerHTML = text_out;
					await print_response_to_frontend();
					return "stop";
				} else {
					return "run";
				}
			})
			.then(async function(flag) { await new Promise(r => setTimeout(r, 10000)); return flag; })
			.catch(error => { document.getElementById("error").innerHTML = error; });
		i += 1;
		console.log('i: ', i);
	}
}
	
// -----------------------------------------------
	
async function print_result() {
	await GET_repo_file_info_RESTAPI_fast()
		.then(async function (text_out) { 
			if (text_out != '404: Not Found') {
				document.getElementById('response').innerHTML = text_out;
				await print_response_to_frontend(); 
			}
		})
		.catch(error => { document.getElementById("error").innerHTML = error; });
}


async function GET_repo_file_info_RESTAPI_fast() {
	return await fetch(`https://raw.githubusercontent.com/CodeSolutions2/my_chatbot/main/${document.getElementById('output_file_path').innerHTML}`)
		.then(res => res.text())
		.then(async function (text_out) { return  text_out; })
		.catch(error => { console.log(error); });
}

// -----------------------------------------------
	
async function print_response_to_frontend() {

	document.getElementById("chatbot_output").style.display = "block";
	
	// Print response to Frontend here
	let tbl = document.getElementById("chatbot_output");
	let tblBody = document.createElement("tbody");
	
	// Add to Frontend: Create a cellText OR textarea
	let row = document.createElement("tr");
	let cell = document.createElement("td");
	cell.style.backgroundColor = "#cacccf";
	let cellText = document.createTextNode(`User: ${document.getElementById("input_text").value}`);
	cell.appendChild(cellText);
	cell.style.border = "10px solid rgba(0, 0, 0, 0)";
	row.appendChild(cell);
	tblBody.appendChild(row);
	tbl.appendChild(tblBody);
	
	// Add chatbot output to Frontend: Create a cellText OR textarea
	row = document.createElement("tr");
	cell = document.createElement("td");
	cell.style.backgroundColor = "#dbc49e";
	cellText = document.createTextNode(`Chatbot: ${document.getElementById('response').innerHTML}`);
	cell.appendChild(cellText);
	cell.style.border = "10px solid rgba(0, 0, 0, 0)";
	row.appendChild(cell);
	tblBody.appendChild(row);
	tbl.appendChild(tblBody);

	// Reset response
	document.getElementById('response').innerHTML = "";
	
}

// -----------------------------------------------



// ----------------------------------------------------
// SUBFUNCTIONS
// ----------------------------------------------------
async function run_backend_process(RepoAobj) {

	// RepoAobj.repoOwner, RepoAobj.repoA_name, RepoAobj.foldername, RepoAobj.filename, RepoAobj.input, RepoAobj.repoB_name
	
	// n is the maximum salt length used
	
	var obj_env = await GET_text_from_file_wo_auth_GitHub_RESTAPI(".env", ".github", RepoAobj.repoB_name);
	
	var obj = {env_text: obj_env.text.replace(/[\n\s]/g, ""), 
		   env_file_download_url: obj_env.file_download_url, 
		   env_sha: obj_env.sha, 
		   n: 1, 
		   filename: RepoAobj.filename, 
		   foldername: RepoAobj.foldername, 
		   input_text: RepoAobj.input, 
		   repoB_name: RepoAobj.repoB_name};
	console.log('obj: ', obj);

	Object.freeze(obj.env_text); // make the original value non-changeable
	await run_backend(obj);
	
}


// ----------------------------------------------------

	
async function run_backend(obj) {
	
	// Try each of the 'de-salted' authorization keys to identify the correct key: loop over a REST API request and identify which key succeeds
	// console.log('obj.repoB_name: ', obj.repoB_name);
	
	// [0] Determine if filename exists
	var obj_temp = await GET_fileDownloadUrl_and_sha(obj.filename, obj.foldername, obj.repoB_name)

	// [1] Add obj_env and obj_temp to the general object (obj)
	// obj.env_text
	// obj.env_file_download_url
	// obj.env_sha
	obj.env_desired_path = obj.env_file_download_url.split('main/').pop();
	// console.log('obj.env_desired_path: ', obj.env_desired_path);
	
	obj.temp_file_download_url = obj_temp.file_download_url[0]; // this is a string
	obj.temp_desired_path = obj.temp_file_download_url.split('main/').pop();
	obj.temp_sha = obj_temp.sha_arr[0]; // this is a string

	obj.env_text = "MHRlc3QgdGVzdA==";
	obj.auth = obj.env_text; // Initialize value
	obj.status = false; // Initialize value
		
	// [2] Loop over the number of possible values
	let i = 0;
	var regexp = /^20/g;
	var x = Array.from({ length: (obj.n*2)+1 }, (_, ind) => ind);
	// console.log('x: ', x);
	
	var x_rand = await rand_perm(x);
	console.log('x_rand: ', x_rand);
	console.log('obj.n: ', obj.n);
	console.log('(obj.n*2)+1: ', (obj.n*2)+1);

	try {
		while (regexp.test(obj.status) == false && obj.auth != null && i < (obj.n*2)+1) {
			
			obj = await decode_desalt(obj, x_rand[i])
				.then(async function(obj) {

					// Test 
					if (document.getElementById('var3').innerHTML == 'test test') {
						obj.status = true;
						document.getElementById('var3').innerHTML = "";
					}
					
					// Non test program
					// if (obj.temp_file_download_url == "No_file_found") {
						// Option 0: create a new file
					// 	obj.status = await PUT_create_a_file_RESTAPI(document.getElementById('var3').innerHTML, 'run GitHub Action', obj.input_text, obj.foldername+"/"+obj.filename, obj.repoB_name)
             //  .then(async function(out) { document.getElementById('var3').innerHTML = ""; return out.status; })
		// 					.catch(error => { document.getElementById("error").innerHTML = error; });
			// 		} else {
						// Option 1: modify an existing file
				// 		obj.status = await PUT_add_to_a_file_RESTAPI(document.getElementById('var3').innerHTML, 'run GitHub Action', obj.input_text, obj.temp_desired_path, obj.temp_sha, obj.repoB_name)
             //  .then(async function(out) { document.getElementById('var3').innerHTML = ""; return out.status; })
		// 					.catch(error => { document.getElementById("error").innerHTML = error; });
			// 		}
					
					if (regexp.test(obj.status) == true) {
						delete obj.auth; // the variable is deleted to force it to stop the loop as quickly as possible, it will then throw an error for the while loop thus the while loop is called in a try catch to prevent errors.
					} else {
						obj.auth = obj.env_text; // reinitialize value to keep the value obj.auth non-visible
					}
          
					console.log("loop i: ", i);
					console.log("x_rand[i]: ", x_rand[i]);
					return obj;
				})
				.then(async function(obj) { await new Promise(r => setTimeout(r, 2000)); return obj; })
			
			// Advance while loop
			i += 1;	
		}
		
	} catch (error) {
		console.log("error: ", error);
		console.log("loop finished!");
	}
		
}

// ----------------------------------------------------

async function decode_desalt(obj, i) {
	
	// 0. Decode the Base64-encoded string --> obtain the salted data in binary string format
	document.getElementById('var0').innerHTML = atob(obj.env_text);
	document.getElementById('var1').innerHTML = i;
	document.getElementById('var2').innerHTML = obj.n;
	document.getElementById('var3').innerHTML = obj.auth;

	await new Promise(r => setTimeout(r, 10))
		.then(async function() {
			// 1. 'de-salt' the authorization key read from the file
			if (document.getElementById('var1').innerHTML == 0) {
				document.getElementById('var3').innerHTML = document.getElementById('var0').innerHTML;
			} else if (document.getElementById('var1').innerHTML <= document.getElementById('var2').innerHTML) {
				// remove end
				document.getElementById('var3').innerHTML = document.getElementById('var0').innerHTML.slice(0, document.getElementById('var0').innerHTML.length - document.getElementById('var1').innerHTML);
			} else {
				// remove beginning 
				document.getElementById('var3').innerHTML = document.getElementById('var0').innerHTML.slice(document.getElementById('var1').innerHTML - document.getElementById('var2').innerHTML, document.getElementById('var0').innerHTML.length);
			}
		})
		.then(async function() {
			document.getElementById('var0').innerHTML = "";
			document.getElementById('var1').innerHTML = "";
			document.getElementById('var2').innerHTML = "";
			
			// De-scramble key
			      // Way 1
			      const arr = document.getElementById('var3').innerHTML.split('').map((val, ind) => {
			        if (ind % 2 == 0){
			            console.log('ind, p: ', ind, Math.floor(ind/2));
			            return document.getElementById('var3').innerHTML.split('').at(Math.floor(ind/2));
			        } else {
			          console.log('ind, ap: ', ind, Math.floor(ind/2) + 1);
			          return document.getElementById('var3').innerHTML.split('').at(Math.floor(ind/2) + 1  + document.getElementById('var3').innerHTML.split('').indexOf('|'));
			        }
			      });
			      console.log('arr: ', arr);
			      const vals_to_Keep = (x) => x != '|';
			      document.getElementById(var3).innerHTML = arr.filter(vals_to_Keep).join('');
			      console.log('document.getElementById(var3).innerHTML: ', document.getElementById('var3').innerHTML);
		})
		.catch(error => { document.getElementById('error').innerHTML = error; });

  return obj;
}

// ----------------------------------------------------



// ----------------------------------------------------
// PUT create a file - Way 0: REST API (WORKS!)
// Can only write to a public repository, can not write to a private repository even if the key grants access
// https://docs.github.com/en/rest/repos/contents?apiVersion=2022-11-28#create-or-update-file-contents
// 
// Before, GitHub copied over the temp file with a new temp.
//
// Now, if the file temp exists it does not copy over the file; it gives a 422 error. One needs to delete the file temp and then use this function to create the file temp. 
// ----------------------------------------------------
async function PUT_create_a_file_RESTAPI(auth, message, content, desired_path, repoName) {
	
	console.log('create repoName: ', repoName);
	console.log('create desired_path: ', desired_path);
	console.log('create auth: ', auth.slice(0,5));
	
	// PUT content into a new file
	var url = `https://api.github.com/repos/CodeSolutions2/${repoName}/contents/${desired_path}`;
	var data = {"message": message, "committer":{"name":"App name","email":"App email"}, "content": btoa(content)};
	var headers = {"Accept": "application/vnd.github+json", "Authorization": `Bearer ${auth}`, "X-GitHub-Api-Version": "2022-11-28"};
	var options = {method : 'PUT', headers: headers, body : JSON.stringify(data)};
	
	return await fetch(url, options)
		.catch(error => { document.getElementById("error").innerHTML = error; });
}


// ----------------------------------------------------


async function PUT_add_to_a_file_RESTAPI(auth, message, content, desired_path, sha, repoName) {

	console.log('create repoName: ', repoName);
	console.log('create desired_path: ', desired_path);
	console.log('create auth: ', auth.slice(0,5));
	
	// PUT content into an existing file
	let url = `https://api.github.com/repos/CodeSolutions2/${repoName}/contents/${desired_path}`;
	var data = {"message": message, "committer":{"name":"App name","email":"App email"}, "content": btoa(content), "sha": sha};
	var headers = {"Accept": "application/vnd.github+json", "Authorization": `Bearer ${auth}`, "X-GitHub-Api-Version": "2022-11-28"};
	var options = {method : 'PUT', headers: headers, body : JSON.stringify(data)};
	
	return await fetch(url, options)
		.catch(error => { document.getElementById("error").innerHTML = error; });
}
	
// ----------------------------------------------------

async function GET_text_from_file_wo_auth_GitHub_RESTAPI(desired_filename, desired_foldername, repoB_name) {

	// Returns an object of strings
	// console.log('GET_text_from_file_wo_auth_GitHub_RESTAPI: ');
	// console.log('desired_filename: ', desired_filename);
	// console.log('desired_foldername: ', desired_foldername);
	// console.log('repoB_name: ', repoB_name);
	
	return await GET_fileDownloadUrl_and_sha(desired_filename, desired_foldername, repoB_name)
		.then(async function (obj) {
			var text = "";
			if (obj.file_download_url != ["No_file_found"]) {
				// fetch on first file
				text = await fetch(obj.file_download_url[0])
					.then(response => response.text())
					.then(async function(text) { return text; });
			}
			return {text: text, file_download_url: obj.file_download_url[0], sha: obj.sha_arr[0]};
		})
		.catch(error => { document.getElementById("error").innerHTML = error; });
}

// ----------------------------------------------------

async function GET_fileDownloadUrl_and_sha(desired_filename, desired_foldername, repoB_name) {

	// Returns an object of values that are an array
	var url = `https://api.github.com/repos/CodeSolutions2/${repoB_name}/contents`;
	// console.log('url: ', url);

	var data = await fetch(url).then(res => res.json());
	// console.log('data: ', data);

	var flag = "run";
	var max_loop_limit = 0;
	var file_download_url = [];
	var folders = [];
	var sha_arr = [];
	
	while (flag == "run" && max_loop_limit < 5) {
		
		// console.log('flag: ', flag);
		// console.log('max_loop_limit: ', max_loop_limit);

		// search over data to find the desired_filename
		var obj = await loop_over_files_and_folders(data, desired_filename, desired_foldername, file_download_url, folders, sha_arr);
		// console.log('obj: ', obj);
		
		folders = folders.concat(obj.folders);
		folders = [... new Set(folders)];
		// console.log('folders: ', folders);
		
		file_download_url = file_download_url.concat(obj.file_download_url);
		file_download_url = [... new Set(file_download_url)];
		// console.log('file_download_url: ', file_download_url);
		
		sha_arr = sha_arr.concat(obj.sha_arr);
		sha_arr = [... new Set(sha_arr)];
		// console.log('sha_arr: ', sha_arr);
		
		// get list of folders from the main directory
		if (folders.length == 0) {
			if (file_download_url.length == 0) { file_download_url = ["No_file_found"]; }
			if (sha_arr.length == 0) { sha_arr = ["No_file_found"]; }
			flag = "stop";
		} else {
			// There are directories in the main file
			data = await fetch(folders.shift())
				.then(res => res.json())
				.then(async function(data) { return data; });
		}
		max_loop_limit += 1;
	}
	
	return {file_download_url: file_download_url, sha_arr: sha_arr};
}

	
async function loop_over_files_and_folders(data, desired_filename, desired_foldername, file_download_url, folders, sha_arr) {
	
	var regexp = new RegExp(`${desired_filename}`, 'g');
	var regexp_foldername = new RegExp(`${desired_foldername}`, 'g');
	
	// run through files per url directory
	let i = 0;
	while (i < data.length && i < 10) {
		
		if (data[i].type === 'file' && data[i].name.match(regexp) && regexp_foldername.test(data[i].download_url) == true) { 
			file_download_url = data[i].download_url;
			sha_arr = data[i].sha;
			// console.log('file_download_url: ', file_download_url);
			// console.log('Desired file found: ', data[i].url);
		} else if (data[i].type === 'dir') {
			// Store url of directories found
			folders.push(data[i].url);
			// console.log('A directory was found: ', data[i].url);
		// } else {
			// console.log('Desired file not found: ', data[i].url);
		}
		i += 1;
		// console.log('i: ', i);
	}
	
	return {file_download_url: file_download_url, folders: folders, sha_arr: sha_arr}; 
}

// ----------------------------------------------------

async function get_number(x) {
	return x[Math.round(x.length*Math.random())-1];
}
	  
async function rand_perm(x) {

	var out = [];
	while (out.length != x.length) {
		out = await get_number(x).then(async function(x_of_y) {
			if (out.includes(x_of_y) == false && typeof x_of_y != "undefined") { 
				out.push(x_of_y);
			}
			return [... new Set(out)]; // ensure that only unique values are stored in out
		});
	}
	
	return out;
	
}  // end of rand_perm

// ----------------------------------------------------

</script>

  
</body>
</html>
